Services are typically involved with co-ordinating logic between [domain classes|guide:GORM], and hence often involved with persistence that spans large operations. Given the nature of services they frequently require transactional behaviour. You can of course use programmatic transactions with the [withTransaction|domainClasses] method, however this is repetitive and doesn't fully leverage the power of Spring's underlying transaction abstraction.

Services allow the enablement of transaction demarcation, which is essentially a declarative way of saying all methods within this service are to be made transactional. To enable transaction demarcation simply set the @transactional@ property to @true@:

{code:java}
class CountryService {
    static transactional = true
}
{code}

{warning}
Warning: [dependency injection|guide:8.3 Dependency Injection and Services] is the *only* way that declarative transactions work. You will not get a transactional service if you use the @new@ operator such as @new BookService()@
{warning}


The result is all methods are wrapped in a transaction and automatic rollback occurs if an exception is thrown in the body of one of the methods. The propagation level of the transaction is by default set to [PROPAGATION_REQUIRED|http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/transaction/TransactionDefinition.html#PROPAGATION_REQUIRED].
