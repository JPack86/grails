h4. Logging Basics

Grails uses its common configuration mechanism to configure the underlying "Log4j":http://logging.apache.org/log4j/1.2/index.html log system. To configure logging you must modify the file @Config.groovy@ located in the @grails-app/conf@ directory. This single @Config.groovy@ file allows you to specify separate logging configurations for @development@, @test@, and @production@ [environments|guide:environments]. Grails processes the @Config.groovy@ file and generates the appropriate @log4j.properties@ file in the @web-app/WEB-INF/classes@ directory.

An example of a typical Log4j configuration in Grails is as follows:

{code:java}
log4j {
    appender.stdout = "org.apache.log4j.ConsoleAppender"
	appender.'stdout.layout'="org.apache.log4j.PatternLayout"
    rootLogger="error,stdout"
    logger {
        grails="info,stdout"
        org {
            grails.spring="info,stdout"
            codehaus.groovy.grails.web="info,stdout"
            codehaus.groovy.grails.commons="info,stdout"
            ...
        }
}
{code}

If you prefer to use standard Log4j properties file style configuration you can use a Groovy multiline String instead:

{code:java}
log4j = '''
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
# ...remaining configuration
'''{code}

Some useful loggers include:

* @org.codehaus.groovy.grails.commons@ - Core artefact information such as class loading etc.
* @org.codehaus.groovy.grails.web@ - Grails web request processing
* @org.codehaus.groovy.grails.web.mapping@ - URL mapping debugging
* @org.codehaus.groovy.grails.plugins@ - Log plugin activity
* @org.springframework@ - See what Spring is doing
* @org.hibernate@ - See what Hibernate is doing

h4. Full stacktraces

When exceptions occur, there can be an awful lot of noise in the stacktrace from Java and Groovy internals. Grails filters these typically irrelevant details and restricts traces to non-core Grails/Groovy class packages.

When this happens, the full trace is always written to the @StackTrace@ logger. This logs to a file called @stacktrace.log@ - but you can change this in your @Config.groovy@ to do anything you like. For example if you prefer full stack traces to go to standard out you can change the line:

{code:java}
StackTrace="error,errors"
{code}

To:

{code:java}
StackTrace="error,stdout"
{code}

You can completely disable stacktrace filtering by setting the @grails.full.stacktrace@ VM property to @true@:

{code:java}
grails -Dgrails.full.stacktrace=true run-app
{code}

h4. Logging by Convention

All application artefacts have a dynamically added @log@ property. This includes [domain classes|guide:GORM], [controllers|guide:controllers], tag libraries and so on. Below is an example of its usage:

{code:java}
def foo = "bar"
log.debug "The value of foo is $foo"
{code}

Logs are named using the convention @grails.app.<artefactType>.ClassName@. Below is an example of how to configure logs for different Grails artefacts:

{code:java}
# Set level for all application artefacts
log4j.logger.grails.app="info, stdout"

# Set for a specific controller
log4j.logger.grails.app.controller.YourController="debug, stdout"

# Set for a specific domain class
log4j.logger.grails.app.domain.Book="debug, stdout"

# Set for a specific taglib
log4j.logger.grails.app.tagLib.FancyAjax="debug, stdout"

# Set for all taglibs
log4j.logger.grails.app.tagLib="info, stdout"
{code}

The artefacts names are dictated by convention, some of the common ones are listed below:

* @bootstrap@ - For bootstrap classes
* @dataSource@ - For data sources
* @tagLib@ - For tag libraries
* @service@ - For service classes
* @controller@ - For controllers
* @domain@ - For domain entities
