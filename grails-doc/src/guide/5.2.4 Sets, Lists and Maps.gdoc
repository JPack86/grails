h4. Sets of objects

By default when you define a relationship with GORM it is a @java.util.Set@ which is an unordered collection that cannot contain duplicates. In other words when you have:

{code}
class Author {
   static hasMany = [books:Book]
}
{code}

The books property that GORM injects is a @java.util.Set@. The problem with this is there is no ordering when accessing the collection, which may not be what you want. To get custom ordering you can say that the set is a @SortedSet@:

{code}
class Author {
   SortedSet books
   static hasMany = [books:Book]
}
{code}

In this case a @java.util.SortedSet@ implementation is used which means you have to implement @java.lang.Comparable@ in your Book class:

{code}
class Book implements Comparable {
   String title
   Date releaseDate = new Date()

   int compareTo(obj) {
       releaseDate.compareTo(obj.releaseDate)
   }
}
{code}

The result of the above class is that the Book instances in the books collections of the Author class will be ordered by their release date.

h4. Lists of objects

If you simply want to be able to keep objects in the order which they were added and to be able to reference them by index like an array you can define your collection type as a @List@:

{code}
class Author {
   List books
   static hasMany = [books:Book]
}
{code}

In this case when you add new elements to the books collection the order is retained in a sequential list indexed from 0 so you can do:

{code}
author.books[0] // get the first book
{code}

The way this works at the database level is Hibernate creates a @books_idx@ column where it saves the index of the elements in the collection in order to retain this order at the db level.

When using a @List@, elements must be added to the collection before being saved, otherwise Hibernate will throw an exception (@org.hibernate.HibernateException@: null index column for collection):

{code}
// This won't work!
def book = new Book(title: 'The Shining')
book.save()
author.addToBooks(book)

// Do it this way instead.
def book = new Book(title: 'Misery')
author.addToBooks(book)
author.save()
{code}

h4. Maps of Objects

If you want a simple map of string/value pairs GORM can map this with the following:

{code}
class Author {
   Map books // my of ISBN:book names
}

def a = new Author()
a.books = ["1590597583":"Grails Book"]
a.save()
{code}
In this case the key and value of the map MUST be strings.

If you want a Map of objects then you can do this:

{code}
class Book {
  Map authors
  static hasMany = [authors:Author]
}

def a = new Author(name:"Stephen King")

def book = new Book()
book.authors = [stephen:a]
book.save()
{code}

The static @hasMany@ property defines the type of the elements within the Map. The keys for the map *must* be strings.